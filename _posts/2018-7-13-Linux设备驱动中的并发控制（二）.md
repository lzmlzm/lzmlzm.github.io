---
layout:     post
title:      Linux设备驱动中的并发控制（二）之信号量和互斥体
subtitle:   Linux驱动
date:       2018-7-13
author:     Muggle
header-img:
catalog: 	 true
tags:
    - Linux驱动概念
---

# 一、信号量
信号量（Semaphore)是操作系统中最典型的用于同步和互斥的手段，信号量的值可以是0、1、或者N.信号量与操作系统中的经典概念PV操作对应。
P(S):
**如果信号量S的值大于0，该进程继续执行
**
<br>
如果S的值为0，该进程进入等待状态，排入信号量的等待队列，知道V操作将其唤醒。
信号量的使用步骤：。
	定义信号量结构体
	初始化信号量
	获得信号量
	临界区代码
	释放信号量
生产者/消费者模型使用信号量较为合适。

# 二、互斥体
互斥体是真正的mutex，使用步骤和信号量一致，只是函数不同，下面我们来看看它们的不同。



# 三、自旋锁和互斥体的选择取舍
1.自旋锁和互斥体都是解决互斥问题的基本手段，面对特定的情况，我们选择的依据是临界区的性质和系统的特点。
2.互斥体和自旋锁属于不同层次的互斥手段，互斥体的实现依赖于自旋锁。在实现互斥体本身上，为了保证互斥体结构存取的原子性，需要用到自旋锁来互斥。**所以自旋锁更加底层**。
3.互斥体是进程级别的，用于多个进程之间对资源的互斥。只有进程**占用资源时间较长**时，使用**互斥体**才是较好的选择。当对于要保护的**临界区访问时间较短**时，使用**自旋锁**最方便，因为它节约了上下文切换的时间。
## 使用总结
**① 若临界区较小，宜使用自旋锁；若临界区较大，宜使用互斥体。**<br>
**② 互斥体保护的临界区可以包含可能引起阻塞的代码；而自旋锁要避开包含可能引起阻塞的代码。因为阻塞意味着进程上下文的切换，如果这个进程被切出去，那么切进来的进程就会尝试获得这个自旋锁，这个时候就会发生死锁。**<br>
**③ 互斥体存在于进程上下文。因此如果被保护的资源需要在中断的情况下使用，只能使用自旋锁。当然如果想使用互斥体，可以通过**mutex_trylock()**方式进行们不能获得就立即返回避免阻塞。**
