# Scrapy学习心得（一）

标签（空格分隔）： Scrapy

---


    /html/head/title: 选择HTML文档中 <head> 标签内的 <title> 元素
    /html/head/title/text(): 选择上面提到的 <title> 元素的文字
    //td: 选择所有的 <td> 元素
    //div[@class="mine"]: 选择所有具有 class="mine" 属性的 div 元素
    

CSS选择元素
提取标题

尝试使用带有响应对象的CSS选择元素：

>>> response.css('title')
[<Selector xpath='descendant-or-self::title' data='<title>Quotes to Scrape</title>'>]

返回一个Selector 的集合。

从上面的标题中提取文本，您可以：

>>> response.css('title::text').extract()
['Quotes to Scrape']

这里有两个要注意的事情：一个是我们添加::text到CSS查询，意味着我们要直接在\元素内部选择文本元素 。如果我们不指定::text，我们将获得完整的title元素，包括其标签：

>>> response.css('title').extract()
['<title>Quotes to Scrape</title>']


另一件事是调用的结果.extract()是一个列表，因为我们处理的是一个实例SelectorList。当你知道你只想要第一个结果，在这种情况下，你可以做：

>>> response.css('title::text').extract_first()
'Quotes to Scrape'


也可以这样写：

>>> response.css('title::text')[0].extract()
'Quotes to Scrape'

但是，使用.extract_first()避免了IndexError，并且None在找不到与选择匹配的任何元素时返回 。

除了extract()和 extract_first()方法，您还可以使用该re()方法使用正则表达式提取：

>>> response.css('title::text').re(r'Quotes.*')
['Quotes to Scrape']
>>> response.css('title::text').re(r'Q\w+')
['Quotes']
>>> response.css('title::text').re(r'(\w+) to (\w+)')
['Quotes', 'Scrape']



了找到合适的CSS选择器使用，您可以用chrome和Firefox 的调试工具查看css。

----------------------------------------------------------------------
----------------------------------------------------------------------




